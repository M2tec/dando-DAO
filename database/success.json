{
    "data": {
     "updateGQLSchema": {
      "gqlSchema": {
       "schema": "type Dno { id: ID! firstName: String lastName: String address: String nodeUrl: String uptimes: [Uptime]}type Uptime { id: ID! uptimeData: [String] dnoId: Int dno: Dno}",
       "generatedSchema": "#######################\n# Input Schema\n#######################\n\ntype Dno {\n\tid: ID!\n\tfirstName: String\n\tlastName: String\n\taddress: String\n\tnodeUrl: String\n\tuptimes(filter: UptimeFilter, order: UptimeOrder, first: Int, offset: Int): [Uptime]\n\tuptimesAggregate(filter: UptimeFilter): UptimeAggregateResult\n}\n\ntype Uptime {\n\tid: ID!\n\tuptimeData: [String]\n\tdnoId: Int\n\tdno(filter: DnoFilter): Dno\n}\n\n#######################\n# Extended Definitions\n#######################\n\n\"\"\"\nThe Int64 scalar type represents a signed 64\u2010bit numeric non\u2010fractional value.\nInt64 can represent values in range [-(2^63),(2^63 - 1)].\n\"\"\"\nscalar Int64\n\n\"\"\"\nThe DateTime scalar type represents date and time as a string in RFC3339 format.\nFor example: \"1985-04-12T23:20:50.52Z\" represents 20 mins 50.52 secs after the 23rd hour of Apr 12th 1985 in UTC.\n\"\"\"\nscalar DateTime\n\ninput IntRange{\n\tmin: Int!\n\tmax: Int!\n}\n\ninput FloatRange{\n\tmin: Float!\n\tmax: Float!\n}\n\ninput Int64Range{\n\tmin: Int64!\n\tmax: Int64!\n}\n\ninput DateTimeRange{\n\tmin: DateTime!\n\tmax: DateTime!\n}\n\ninput StringRange{\n\tmin: String!\n\tmax: String!\n}\n\nenum DgraphIndex {\n\tint\n\tint64\n\tfloat\n\tbool\n\thash\n\texact\n\tterm\n\tfulltext\n\ttrigram\n\tregexp\n\tyear\n\tmonth\n\tday\n\thour\n\tgeo\n\thnsw\n}\n\ninput AuthRule {\n\tand: [AuthRule]\n\tor: [AuthRule]\n\tnot: AuthRule\n\trule: String\n}\n\nenum HTTPMethod {\n\tGET\n\tPOST\n\tPUT\n\tPATCH\n\tDELETE\n}\n\nenum Mode {\n\tBATCH\n\tSINGLE\n}\n\ninput CustomHTTP {\n\turl: String!\n\tmethod: HTTPMethod!\n\tbody: String\n\tgraphql: String\n\tmode: Mode\n\tforwardHeaders: [String!]\n\tsecretHeaders: [String!]\n\tintrospectionHeaders: [String!]\n\tskipIntrospection: Boolean\n}\n\ninput DgraphDefault {\n\tvalue: String\n}\n\ntype Point {\n\tlongitude: Float!\n\tlatitude: Float!\n}\n\ninput PointRef {\n\tlongitude: Float!\n\tlatitude: Float!\n}\n\ninput NearFilter {\n\tdistance: Float!\n\tcoordinate: PointRef!\n}\n\ninput PointGeoFilter {\n\tnear: NearFilter\n\twithin: WithinFilter\n}\n\ntype PointList {\n\tpoints: [Point!]!\n}\n\ninput PointListRef {\n\tpoints: [PointRef!]!\n}\n\ntype Polygon {\n\tcoordinates: [PointList!]!\n}\n\ninput PolygonRef {\n\tcoordinates: [PointListRef!]!\n}\n\ntype MultiPolygon {\n\tpolygons: [Polygon!]!\n}\n\ninput MultiPolygonRef {\n\tpolygons: [PolygonRef!]!\n}\n\ninput WithinFilter {\n\tpolygon: PolygonRef!\n}\n\ninput ContainsFilter {\n\tpoint: PointRef\n\tpolygon: PolygonRef\n}\n\ninput IntersectsFilter {\n\tpolygon: PolygonRef\n\tmultiPolygon: MultiPolygonRef\n}\n\ninput PolygonGeoFilter {\n\tnear: NearFilter\n\twithin: WithinFilter\n\tcontains: ContainsFilter\n\tintersects: IntersectsFilter\n}\n\ninput GenerateQueryParams {\n\tget: Boolean\n\tquery: Boolean\n\tpassword: Boolean\n\taggregate: Boolean\n}\n\ninput GenerateMutationParams {\n\tadd: Boolean\n\tupdate: Boolean\n\tdelete: Boolean\n}\n\ndirective @hasInverse(field: String!) on FIELD_DEFINITION\ndirective @search(by: [String!]) on FIELD_DEFINITION\ndirective @embedding on FIELD_DEFINITION\ndirective @dgraph(type: String, pred: String) on OBJECT | INTERFACE | FIELD_DEFINITION\ndirective @id(interface: Boolean) on FIELD_DEFINITION\ndirective @default(add: DgraphDefault, update: DgraphDefault) on FIELD_DEFINITION\ndirective @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION\ndirective @secret(field: String!, pred: String) on OBJECT | INTERFACE\ndirective @auth(\n\tpassword: AuthRule\n\tquery: AuthRule,\n\tadd: AuthRule,\n\tupdate: AuthRule,\n\tdelete: AuthRule) on OBJECT | INTERFACE\ndirective @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION\ndirective @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM\ndirective @remoteResponse(name: String) on FIELD_DEFINITION\ndirective @cascade(fields: [String]) on FIELD\ndirective @lambda on FIELD_DEFINITION\ndirective @lambdaOnMutate(add: Boolean, update: Boolean, delete: Boolean) on OBJECT | INTERFACE\ndirective @cacheControl(maxAge: Int!) on QUERY\ndirective @generate(\n\tquery: GenerateQueryParams,\n\tmutation: GenerateMutationParams,\n\tsubscription: Boolean) on OBJECT | INTERFACE\n\ninput IntFilter {\n\teq: Int\n\tin: [Int]\n\tle: Int\n\tlt: Int\n\tge: Int\n\tgt: Int\n\tbetween: IntRange\n}\n\ninput Int64Filter {\n\teq: Int64\n\tin: [Int64]\n\tle: Int64\n\tlt: Int64\n\tge: Int64\n\tgt: Int64\n\tbetween: Int64Range\n}\n\ninput FloatFilter {\n\teq: Float\n\tin: [Float]\n\tle: Float\n\tlt: Float\n\tge: Float\n\tgt: Float\n\tbetween: FloatRange\n}\n\ninput DateTimeFilter {\n\teq: DateTime\n\tin: [DateTime]\n\tle: DateTime\n\tlt: DateTime\n\tge: DateTime\n\tgt: DateTime\n\tbetween: DateTimeRange\n}\n\ninput StringTermFilter {\n\tallofterms: String\n\tanyofterms: String\n}\n\ninput StringRegExpFilter {\n\tregexp: String\n}\n\ninput StringFullTextFilter {\n\talloftext: String\n\tanyoftext: String\n}\n\ninput StringExactFilter {\n\teq: String\n\tin: [String]\n\tle: String\n\tlt: String\n\tge: String\n\tgt: String\n\tbetween: StringRange\n}\n\ninput StringHashFilter {\n\teq: String\n\tin: [String]\n}\n\n#######################\n# Generated Types\n#######################\n\ntype AddDnoPayload {\n\tdno(filter: DnoFilter, order: DnoOrder, first: Int, offset: Int): [Dno]\n\tnumUids: Int\n}\n\ntype AddUptimePayload {\n\tuptime(filter: UptimeFilter, order: UptimeOrder, first: Int, offset: Int): [Uptime]\n\tnumUids: Int\n}\n\ntype DeleteDnoPayload {\n\tdno(filter: DnoFilter, order: DnoOrder, first: Int, offset: Int): [Dno]\n\tmsg: String\n\tnumUids: Int\n}\n\ntype DeleteUptimePayload {\n\tuptime(filter: UptimeFilter, order: UptimeOrder, first: Int, offset: Int): [Uptime]\n\tmsg: String\n\tnumUids: Int\n}\n\ntype DnoAggregateResult {\n\tcount: Int\n\tfirstNameMin: String\n\tfirstNameMax: String\n\tlastNameMin: String\n\tlastNameMax: String\n\taddressMin: String\n\taddressMax: String\n\tnodeUrlMin: String\n\tnodeUrlMax: String\n}\n\ntype UpdateDnoPayload {\n\tdno(filter: DnoFilter, order: DnoOrder, first: Int, offset: Int): [Dno]\n\tnumUids: Int\n}\n\ntype UpdateUptimePayload {\n\tuptime(filter: UptimeFilter, order: UptimeOrder, first: Int, offset: Int): [Uptime]\n\tnumUids: Int\n}\n\ntype UptimeAggregateResult {\n\tcount: Int\n\tdnoIdMin: Int\n\tdnoIdMax: Int\n\tdnoIdSum: Int\n\tdnoIdAvg: Float\n}\n\n#######################\n# Generated Enums\n#######################\n\nenum DnoHasFilter {\n\tfirstName\n\tlastName\n\taddress\n\tnodeUrl\n\tuptimes\n}\n\nenum DnoOrderable {\n\tfirstName\n\tlastName\n\taddress\n\tnodeUrl\n}\n\nenum UptimeHasFilter {\n\tuptimeData\n\tdnoId\n\tdno\n}\n\nenum UptimeOrderable {\n\tdnoId\n}\n\n#######################\n# Generated Inputs\n#######################\n\ninput AddDnoInput {\n\tfirstName: String\n\tlastName: String\n\taddress: String\n\tnodeUrl: String\n\tuptimes: [UptimeRef]\n}\n\ninput AddUptimeInput {\n\tuptimeData: [String]\n\tdnoId: Int\n\tdno: DnoRef\n}\n\ninput DnoFilter {\n\tid: [ID!]\n\thas: [DnoHasFilter]\n\tand: [DnoFilter]\n\tor: [DnoFilter]\n\tnot: DnoFilter\n}\n\ninput DnoOrder {\n\tasc: DnoOrderable\n\tdesc: DnoOrderable\n\tthen: DnoOrder\n}\n\ninput DnoPatch {\n\tfirstName: String\n\tlastName: String\n\taddress: String\n\tnodeUrl: String\n\tuptimes: [UptimeRef]\n}\n\ninput DnoRef {\n\tid: ID\n\tfirstName: String\n\tlastName: String\n\taddress: String\n\tnodeUrl: String\n\tuptimes: [UptimeRef]\n}\n\ninput UpdateDnoInput {\n\tfilter: DnoFilter!\n\tset: DnoPatch\n\tremove: DnoPatch\n}\n\ninput UpdateUptimeInput {\n\tfilter: UptimeFilter!\n\tset: UptimePatch\n\tremove: UptimePatch\n}\n\ninput UptimeFilter {\n\tid: [ID!]\n\thas: [UptimeHasFilter]\n\tand: [UptimeFilter]\n\tor: [UptimeFilter]\n\tnot: UptimeFilter\n}\n\ninput UptimeOrder {\n\tasc: UptimeOrderable\n\tdesc: UptimeOrderable\n\tthen: UptimeOrder\n}\n\ninput UptimePatch {\n\tuptimeData: [String]\n\tdnoId: Int\n\tdno: DnoRef\n}\n\ninput UptimeRef {\n\tid: ID\n\tuptimeData: [String]\n\tdnoId: Int\n\tdno: DnoRef\n}\n\n#######################\n# Generated Query\n#######################\n\ntype Query {\n\tgetDno(id: ID!): Dno\n\tqueryDno(filter: DnoFilter, order: DnoOrder, first: Int, offset: Int): [Dno]\n\taggregateDno(filter: DnoFilter): DnoAggregateResult\n\tgetUptime(id: ID!): Uptime\n\tqueryUptime(filter: UptimeFilter, order: UptimeOrder, first: Int, offset: Int): [Uptime]\n\taggregateUptime(filter: UptimeFilter): UptimeAggregateResult\n}\n\n#######################\n# Generated Mutations\n#######################\n\ntype Mutation {\n\taddDno(input: [AddDnoInput!]!): AddDnoPayload\n\tupdateDno(input: UpdateDnoInput!): UpdateDnoPayload\n\tdeleteDno(filter: DnoFilter!): DeleteDnoPayload\n\taddUptime(input: [AddUptimeInput!]!): AddUptimePayload\n\tupdateUptime(input: UpdateUptimeInput!): UpdateUptimePayload\n\tdeleteUptime(filter: UptimeFilter!): DeleteUptimePayload\n}\n\n"
      }
     }
    },
    "extensions": {
     "tracing": {
      "version": 1,
      "startTime": "2025-02-28T10:18:46.397985021Z",
      "endTime": "2025-02-28T10:18:46.41525292Z",
      "duration": 17267950
     }
    }
   }
   